package Library

import (
    "crypto/md5"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "github.com/go-redis/redis/v8"
    "net/url"
    "os"
    "os/exec"
    "reflect"
    "strconv"
    "strings"
    "time"
)

type command struct {
    cronTask     int
    taskKey      string
    script       string
    controller   string
    function     string
    param        interface{}
    uniqueTaskId string
}

type ServFunc struct {
    StopWorker int
    WorkerKey  string
    Config     Config
    rdb        *redis.Client
}

func NewServFunc() (Serv *ServFunc, err error) {
    Serv = nil
    conf, err := GetConf()
    if err != nil {
        return
    }
    rdb, err := Rdlink()
    if err != nil {
        return
    }
    workerKey := conf.Redis.RedisPrefix + conf.Setting.WorkerName + "Task:Worker"
    Serv = &ServFunc{Config: conf, rdb: rdb, WorkerKey: workerKey}
    return
}

// Start 开始程序
func (s *ServFunc) Start() error {
    fmt.Println("ServFunc Start")
    //清除非配置中的Worker
    keys := s.rdb.Keys(ctx, s.WorkerKey+":*")
    for _, v := range keys.Val() {
        tmp := strings.Split(v, ":")
        if _, ok := s.Config.Worker[tmp[2]]; !ok {
            s.rdb.Del(ctx, s.WorkerKey+":"+tmp[2])
        }
    }
    //开启定时协程
    go s.tick()
    //初始化已停止进程数据
    s.StopWorker = 0
    //添加任务协程状态数据
    for _, v := range s.Config.Worker {
        s.rdb.HSet(ctx, s.WorkerKey+":"+v.TaskKey, "task_key", v.TaskKey)
        s.rdb.HSet(ctx, s.WorkerKey+":"+v.TaskKey, "running_task", 0)
        s.rdb.HSet(ctx, s.WorkerKey+":"+v.TaskKey, "run_time", time.Unix(time.Now().Unix(), 0).Format("2006-01-02 15:04:05"))
        s.rdb.HSet(ctx, s.WorkerKey+":"+v.TaskKey, "status", v.Status)
        if v.Status == "running" {
            //开启任务协程
            if v.WorkerType == "sync" {
                go s.sync(v.TaskKey)
            } else if v.WorkerType == "async" {
                go s.async(v.TaskKey)
            }
        }
    }
    fmt.Println("ServFunc running")
    return nil
}

//定时任务方法
func (s *ServFunc) tick() {
    println("tick start")
    //ticker := time.NewTicker(time.Second)
    ticker := time.NewTicker(time.Millisecond)
    for range ticker.C { //遍历ticker.C，如果有值，则会执行，否则阻塞
        limitTime := []int{
            time.Now().Second(),
            time.Now().Minute(),
            time.Now().Hour(),
            time.Now().Day(),
            int(time.Now().Month()),
            time.Now().Year(),
        }
        for _, cronv := range s.Config.Cron {
            status := s.rdb.HGet(ctx, s.WorkerKey+":"+cronv.TaskKey, "status").Val()
            //fmt.Printf("队列信息:cron-%v;key-%s;status-%v\n", cronv, s.WorkerKey+":"+cronv.TaskKey, status)
            if cronv.TaskKey != "" && status == "running" {
                if r := s.tickCheck(cronv.RunTime, limitTime); r == true {
                    command := map[string]string{
                        "cronTask":     "1",
                        "taskKey":      cronv.TaskKey,
                        "script":       cronv.Script,
                        "controller":   cronv.Controller,
                        "function":     cronv.Function,
                        "param":        cronv.Param,
                        "uniqueTaskId": cronv.UniqueTaskId + s.uniqueTaskId(),
                    }
                    jsonBytes, err := json.Marshal(command)
                    if err != nil {
                        continue
                    }
                    //fmt.Printf("投递定时任务内容：command-%v;json-%v;\n", command, string(jsonBytes))
                    err = s.rdb.HSet(ctx, command["taskKey"]+"_command", command["uniqueTaskId"], string(jsonBytes)).Err()
                    if err != nil {
                        fmt.Printf("投递定时任务错误")
                        continue
                    }
                    s.rdb.RPush(ctx, command["taskKey"], command["uniqueTaskId"])
                    fmt.Printf("投递定时任务:taskKey-%v,uniqueTaskId-%v;\n", command["taskKey"], command["uniqueTaskId"])
                }
            }
        }
    }
    println("tick end")
}

//定时任务时间检查
func (s ServFunc) tickCheck(runTime string, limitTime []int) (r bool) {
    r = false
    runTimeArr := TrimEmpty(strings.Split(runTime, " "))
    if len(runTimeArr) < 5 {
        return
    }
    runSec := false
    if runTimeArr[0] == "*" {
        runSec = true
    } else {
        var runTime0 []string
        if find := strings.Contains(runTimeArr[0], ","); find {
            runTime0 = TrimEmpty(strings.Split(runTimeArr[0], ","))
        } else {
            runTime0 = []string{runTimeArr[0]}
        }
        if runTime0[0] == "" {
            return
        }
        for _, v := range runTime0 {
            if find := strings.Contains(v, "/"); find {
                if tmp := TrimEmpty(strings.Split(v, "/")); tmp[0] == "*" {
                    if s, _ := strconv.Atoi(tmp[1]); (limitTime[0] % s) == 0 {
                        runSec = true
                        break
                    }
                }
            } else if find := strings.Contains(v, "-"); find {
                tmp := TrimEmpty(strings.Split(v, "-"))
                s1, _ := strconv.Atoi(tmp[0])
                s2, _ := strconv.Atoi(tmp[0])
                if s1 <= limitTime[0] && s2 >= limitTime[0] {
                    runSec = true
                    break
                }
            } else {
                s, _ := strconv.Atoi(v)
                if s == limitTime[0] {
                    runSec = true
                    break
                }
            }
        }
    }
    runMinute := false
    if runTimeArr[1] == "*" {
        runMinute = true
    } else {
        var runTime0 []string
        if find := strings.Contains(runTimeArr[1], ","); find {
            runTime0 = TrimEmpty(strings.Split(runTimeArr[1], ","))
        } else {
            runTime0 = []string{runTimeArr[1]}
        }
        if runTime0[0] == "" {
            return
        }
        for _, v := range runTime0 {
            if find := strings.Contains(v, "/"); find {
                if tmp := TrimEmpty(strings.Split(v, "/")); tmp[0] == "*" {
                    if s, _ := strconv.Atoi(tmp[1]); (limitTime[1] % s) == 0 {
                        runMinute = true
                        break
                    }
                }
            } else if find := strings.Contains(v, "-"); find {
                tmp := TrimEmpty(strings.Split(v, "-"))
                s1, _ := strconv.Atoi(tmp[0])
                s2, _ := strconv.Atoi(tmp[0])
                if s1 <= limitTime[1] && s2 >= limitTime[1] {
                    runMinute = true
                    break
                }
            } else {
                s, _ := strconv.Atoi(v)
                if s == limitTime[1] {
                    runMinute = true
                    break
                }
            }
        }
    }
    runHour := false
    if runTimeArr[2] == "*" {
        runHour = true
    } else {
        var runTime0 []string
        if find := strings.Contains(runTimeArr[2], ","); find {
            runTime0 = TrimEmpty(strings.Split(runTimeArr[2], ","))
        } else {
            runTime0 = []string{runTimeArr[2]}
        }
        if runTime0[0] == "" {
            return
        }
        for _, v := range runTime0 {
            if find := strings.Contains(v, "/"); find {
                if tmp := TrimEmpty(strings.Split(v, "/")); tmp[0] == "*" {
                    if s, _ := strconv.Atoi(tmp[1]); (limitTime[2] % s) == 0 {
                        runHour = true
                        break
                    }
                }
            } else if find := strings.Contains(v, "-"); find {
                tmp := TrimEmpty(strings.Split(v, "-"))
                s1, _ := strconv.Atoi(tmp[0])
                s2, _ := strconv.Atoi(tmp[0])
                if s1 <= limitTime[2] && s2 >= limitTime[2] {
                    runHour = true
                    break
                }
            } else {
                s, _ := strconv.Atoi(v)
                if s == limitTime[2] {
                    runHour = true
                    break
                }
            }
        }
    }
    runDay := false
    if runTimeArr[3] == "*" {
        runDay = true
    } else {
        var runTime0 []string
        if find := strings.Contains(runTimeArr[3], ","); find {
            runTime0 = TrimEmpty(strings.Split(runTimeArr[3], ","))
        } else {
            runTime0 = []string{runTimeArr[3]}
        }
        if runTime0[0] == "" {
            return
        }
        for _, v := range runTime0 {
            if find := strings.Contains(v, "/"); find {
                if tmp := TrimEmpty(strings.Split(v, "/")); tmp[0] == "*" {
                    if s, _ := strconv.Atoi(tmp[1]); (limitTime[3] % s) == 0 {
                        runDay = true
                        break
                    }
                }
            } else if find := strings.Contains(v, "-"); find {
                tmp := TrimEmpty(strings.Split(v, "-"))
                s1, _ := strconv.Atoi(tmp[0])
                s2, _ := strconv.Atoi(tmp[0])
                if s1 <= limitTime[3] && s2 >= limitTime[3] {
                    runDay = true
                    break
                }
            } else {
                s, _ := strconv.Atoi(v)
                if s == limitTime[3] {
                    runDay = true
                    break
                }
            }
        }
    }
    runMonth := false
    if runTimeArr[4] == "*" {
        runMonth = true
    } else {
        var runTime0 []string
        if find := strings.Contains(runTimeArr[4], ","); find {
            runTime0 = TrimEmpty(strings.Split(runTimeArr[4], ","))
        } else {
            runTime0 = []string{runTimeArr[4]}
        }
        if runTime0[0] == "" {
            return
        }
        for _, v := range runTime0 {
            if find := strings.Contains(v, "/"); find {
                if tmp := TrimEmpty(strings.Split(v, "/")); tmp[0] == "*" {
                    if s, _ := strconv.Atoi(tmp[1]); (limitTime[4] % s) == 0 {
                        runMonth = true
                        break
                    }
                }
            } else if find := strings.Contains(v, "-"); find {
                tmp := TrimEmpty(strings.Split(v, "-"))
                s1, _ := strconv.Atoi(tmp[0])
                s2, _ := strconv.Atoi(tmp[0])
                if s1 <= limitTime[4] && s2 >= limitTime[4] {
                    runMonth = true
                    break
                }
            } else {
                s, _ := strconv.Atoi(v)
                if s == limitTime[4] {
                    runMonth = true
                    break
                }
            }
        }
    }
    if runSec == true && runMinute == true && runHour == true && runDay == true && runMonth == true {
        r = true
    }
    return
}

//同步任务协程
func (s *ServFunc) sync(taskKey string) {
    fmt.Printf("同步任务协程：taskKey-%v开始;\n", taskKey)
    var execCmd *exec.Cmd
    for {
        //获取队列信息
        task := s.rdb.BLPop(ctx, time.Second, taskKey).Val()
        if len(task) > 1 && task[1] != "" {
            //获取命令数据
            taskCommand := make(map[string]string)
            err := json.Unmarshal([]byte(s.rdb.HGet(ctx, taskKey+"_command", task[1]).Val()), &taskCommand)
            if err != nil {
                fmt.Printf("json解析command错误：taskKey-%v,uniqueTaskId-%v,err-%v;\n", taskKey, task[1], err)
                continue
            }
            //删除命令数据
            s.rdb.HDel(ctx, taskKey+"_command", task[1])
            if taskCommand["script"] == "" || taskCommand["controller"] == "" || taskCommand["function"] == "" {
                continue
            }
            execStr := taskCommand["script"] + " " + taskCommand["controller"] + " " + taskCommand["function"]
            if len(taskCommand["param"]) > 0 && taskCommand["param"] != "" {
                typeof := reflect.TypeOf(taskCommand["param"]).Kind().String()
                var param string
                if typeof == "array" || typeof == "map" || typeof == "interface" || typeof == "struct" {
                    jsonBytes, err := json.Marshal(taskCommand["param"])
                    if err != nil {
                        continue
                    }
                    param = string(jsonBytes)
                } else {
                    param = fmt.Sprintf("%v", taskCommand["param"])
                }
                //对参数进行url转义
                execStr += " " + url.QueryEscape(param)
            }
            startRuntime := time.Unix(time.Now().Unix(), 0).Format("2006-01-02 15:04:05")
            execCmd = exec.Command(s.Config.Setting.PhpPath + " " + execStr + " 2>&1")
            output, err := execCmd.Output()
            endRuntime := time.Unix(time.Now().Unix(), 0).Format("2006-01-02 15:04:05")
            if err != nil {
                fmt.Printf("同步队列任务执行失败：%v;\n", err)
                continue
            }
            fmt.Printf("同步队列任务执行开始时间：%v;\n", startRuntime)
            fmt.Printf("同步队列任务执行结束时间：%v;\n", endRuntime)
            fmt.Printf("同步队列任务执行返回：%v;\n", output)
        }
        if s.rdb.HGet(ctx, s.WorkerKey+":"+taskKey, "status").Val() == "running" {
            continue
        }
        break
    }
    //s.rdb.HSet(ctx, s.WorkerKey+":"+taskKey, "status", "stop")
    fmt.Printf("同步任务协程：taskKey-%v退出;\n", taskKey)
    s.StopWorker++
}

//异步任务协程
func (s *ServFunc) async(taskKey string) {
    fmt.Printf("异步任务协程：taskKey-%v开始;\n", taskKey)
    for {
        //获取队列信息
        task := s.rdb.BLPop(ctx, time.Second, taskKey).Val()
        if len(task) > 1 && task[1] != "" {
            go s.doasync(taskKey, task[1])
        }
        if s.rdb.HGet(ctx, s.WorkerKey+":"+taskKey, "status").Val() == "running" {
            continue
        }
        break
    }
    //s.rdb.HSet(ctx, s.WorkerKey+":"+taskKey, "status", "stop")
    fmt.Printf("异步任务协程：taskKey-%v退出;\n", taskKey)
    s.StopWorker++
}

//异步任务协程
func (s *ServFunc) doasync(taskKey string, taskId string) {
    
    var execCmd *exec.Cmd
    //获取命令数据
    var taskCommand map[string]string
    err := json.Unmarshal([]byte(s.rdb.HGet(ctx, taskKey+"_command", taskId).Val()), &taskCommand)
    if err != nil {
        return
    }
    //删除命令数据
    s.rdb.HDel(ctx, taskKey+"_command", taskId)
    if taskCommand["script"] == "" || taskCommand["controller"] == "" || taskCommand["function"] == "" {
        return
    }
    execStr := taskCommand["script"] + " " + taskCommand["controller"] + " " + taskCommand["function"]
    if len(taskCommand["param"]) > 0 && taskCommand["param"] != "" {
        typeof := reflect.TypeOf(taskCommand["param"]).Kind().String()
        var param string
        if typeof == "array" || typeof == "map" || typeof == "interface" || typeof == "struct" {
            jsonBytes, err := json.Marshal(taskCommand["param"])
            if err != nil {
                return
            }
            param = string(jsonBytes)
        } else {
            param = fmt.Sprintf("%v", taskCommand["param"])
        }
        //对参数进行url转义
        execStr += " " + url.QueryEscape(param)
    }
    startRuntime := time.Unix(time.Now().Unix(), 0).Format("2006-01-02 15:04:05")
    execCmd = exec.Command(s.Config.Setting.PhpPath + " " + execStr + " 2>&1")
    output, err := execCmd.Output()
    endRuntime := time.Unix(time.Now().Unix(), 0).Format("2006-01-02 15:04:05")
    if err != nil {
        fmt.Printf("异步队列任务执行失败：%v;\n", err)
        return
    }
    fmt.Printf("异步队列任务执行开始时间：%v;\n", startRuntime)
    fmt.Printf("异步队列任务执行结束时间：%v;\n", endRuntime)
    fmt.Printf("异步队列任务执行返回：%v;\n", output)
}

func (s *ServFunc) ExitServ() {
    fmt.Println("开始结束程序...")
    //更新任务协程状态数据
    for _, v := range s.Config.Worker {
        s.rdb.HSet(ctx, s.WorkerKey+":"+v.TaskKey, "status", "stop")
    }
    sec := 0
    for len(s.Config.Worker) > s.StopWorker {
        time.Sleep(time.Second)
        sec++
        if sec >= 60 {
            break
        }
    }
    fmt.Println("结束程序...")
    os.Exit(0)
}

//获取唯一md5的任务id
func (s ServFunc) uniqueTaskId() string {
    data := []byte(strconv.Itoa(int(time.Now().UnixNano())))
    h := md5.New()
    h.Write(data)
    return hex.EncodeToString(h.Sum(data))
}
